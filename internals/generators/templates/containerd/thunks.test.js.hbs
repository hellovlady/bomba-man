import configureMockStore from 'redux-mock-store'
import thunk from 'redux-thunk'
import fetchMock from 'fetch-mock'

import mockFetch, {
	SUCCESS_RESPONSE_WITH_DATA,
	SUCCESS_RESPONSE_WITHOUT_DATA,
	ERROR_RESPONSE,
	successDataWithValues,
	successDataWithoutValues,
	errorData,
} from 'utils/mockResponse';
import { FETCH_DATA_REQUEST, FETCH_DATA_SUCCESS } from '../constants';
import { dataFetched, dataFetchingError } from '../actions';

const middlewares = [thunk]
const mockStore = configureMockStore(middlewares)

describe('{{properCase name}} async fetch actions', () => {
    let store;

    // set up a fake store for all our tests
    beforeEach(() => {
    	store = mockStore({ data: null, error: null, loading: false });
    });

	
	it('dispatches the correct action and payload', () => {
		const expectedActions = [
			{
				'payload': 1,
				'type': 'select_avatar',
			},
		];

		store.dispatch(selectActions.selectAvatar(1));
		expect(store.getActions()).toEqual(expectedActions);
	});

	it('should execute fetch data', () => {
		store.dispatch(fetchData())
			.then(() => {
				const actions = store.getActions()
				expect(actions[0]).toEqual(success())
			})
	})
	
  	it('should execute fetch data', () => {
		// Return the promise
		return store.dispatch(fetchData())
			.then(() => {
				const actions = store.getActions()
				expect(actions[0]).toEqual(success())
		})
	})

	it('creates FETCH_DATA_SUCCESS when fetching data has been done', () => {
		fetchMock.getOnce('/todos', {
			body: { todos: ['do something'] },
			headers: { 'content-type': 'application/json' }
		})

		const expectedActions = [
			{ type: types.FETCH_TODOS_REQUEST },
			{ type: types.FETCH_DATA_SUCCESS, body: { todos: ['do something'] } }
		]
		const store = mockStore({ todos: [] })

		return store.dispatch(actions.fetchTodos()).then(() => {
			// return of async actions
			expect(store.getActions()).toEqual(expectedActions)
		})
	})
})

describe('getData Thunk', () => {
	it('should create an action to add response data', () => {
		const response = [
			{
				data: 'Some data',
			},
			{
				data: 'Other data',
			},
		];
		const expectedAction = {
			type: FETCH_DATA_SUCCESS,
			response
		}
		expect(dataFetched(response)).toEqual(expectedAction)
	})

	it('should dispatch the dataFetched action if it requests the data successfully', () => {
		const response = [
			{
				data: 'Some data',
			},
			{
				data: 'Other data',
			},
		];
		const putDescriptor = getDataGenerator.next(response).value;
		expect(putDescriptor).toEqual(put(dataFetched(response)));
	});

	it('should call the dataFetchingError action if the response errors', () => {
		const response = new Error('Some error');
		const putDescriptor = getDataGenerator.throw(response).value;
		expect(putDescriptor).toEqual(put(dataFetchingError(response)));
	});
});

describe('dataWatcherThunk Thunk', () => {
	const dataWatcherThunk = dataWatcher();

	it('should start task to watch for FETCH_DATA_REQUEST action', () => {
		const takeLatestDescriptor = dataWatcherThunk.next().value;
		expect(takeLatestDescriptor).toEqual(takeLatest(FETCH_DATA_REQUEST, getData));
	});
});
