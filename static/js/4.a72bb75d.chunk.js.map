{"version":3,"sources":["utils/index.ts","animations.tsx","containers/Game/components/DeadCharacter.tsx","containers/Game/components/TileIcon.tsx","containers/Game/components/PowerUp/icons.tsx","containers/Game/components/SpriteCharacter.tsx","containers/Game/components/character-shadow.png","containers/Game/components/character-skin-default.png","hooks/useInterval.tsx","hooks/usePrevious.tsx","utils/npc.ts","store/redux/hooks/usePlayerEvents.tsx"],"names":["sleep","duration","Promise","r","setTimeout","wrapPreventFocusLock","cb","e","currentTarget","blur","doesNotExist","value","undefined","findEnumKeyFromValue","enumerable","key","Object","keys","values","indexOf","bounceAnimation","withOpacity","keyframes","ghostAnimation","size","color","Math","ceil","DeadIcon","props","icon","faBookDead","DeadCharacter","id","explodingDuration","coordinates","top","left","onDeathAnimationComplete","useEffect","$top","$left","$size","$animationDelay","theme","palette","default","TileIcon","styled","div","css","icons","PowerUp","Life","success","faHeart","BombCount","error","faBomb","BombSize","warning","faPrescriptionBottleAlt","MovementSpeed","info","faShoePrints","Wrapper","$name","pixelMultiplier","spriteSize","spriteSheetSize","spriteSheetSquareSize","translateDiff","topDiff","min","labelFontSize","labelTopDiff","floor","labelMaxWidth","length","spriteSizing","spriteSheetSizing","useSpriteCharacterAction","shouldBindEvent","keyboardConfig","onPlayerIsWalking","setDirection","setIsWalking","lastMovementTime","useRef","Date","getTime","handleKeyDown","newDirection","getMoveDirectionFromKeyboardCode","code","getDirection","current","updateDirection","handleKeyUp","delayedCurrentTime","document","addEventListener","removeEventListener","SpriteCharacter","currentOnlinePlayerId","name","style","highlight","isWalking","defaultIsWalking","direction","defaultDirection","Direction","DOWN","isNPC","rest","useState","eventDirection","setEventDirection","eventIsWalking","setEventIsWalking","className","data-facing","data-walking","toString","data-highlight","src","alt","useInterval","callback","delay","shouldStop","savedCallback","clearLastInterval","useCallback","clearInterval","triggerCb","setInterval","usePrevious","ref","window","NPC_DEBUG","Store","NPCScore","log","label","console","filter","Boolean","isDifferentSquare","newCoordinates","oldCoordinates","newYSquare","ySquare","newXSquare","xSquare","oldYSquare","oldXSquare","isSquareAPossibleFire","currentSquareCoordinates","bombs","_fireCoordinates","forEach","playerId","players","coordinatesToSetOnFire","getExplosionResults","gameMap","state","getPoweredUpValue","powerUpConfig","defaults","sizes","flat","squareCoordinates","push","findIndex","fireSquareCoordinates","isAdjacent","dropBombAndRunOrScoreTarget","targetScore","runScore","currentTime","lastBombTime","bombDuration","reduce","acc","dropBomb","generateScore","level","isSquareOutOfBoundaries","map","square","newSquare","IsPossibleFireExit","IsDanger","includes","IsPowerUp","IsStuck","Tile","Empty","IsEmptyTile","Player","score","IsPlayer","Breaking","IsBreakingTile","NonBreaking","IsNonBreakingTile","IsNonAdjacentNonBreakingTile","generateMovementTree","parentId","playerMovementTree","_newYSquare","_newXSquare","LEFT","UP","RIGHT","hasChildren","findNodeWithHighestScore","movementNodes","retVal","getRandomInt","groupMovementNodesByParentId","movementNodesGroupedById","movementNode","movementNodeParentId","getTotalScoreOfAllNodes","movementTree","validMovementNodes","movementNodesGroupedByParentId","entries","groupParentId","_groupParentId","Number","nodeWithHighestScore","parentNodes","some","parentNode","findBestMove","currentCoordinates","usePlayerRefs","playerRefs","P1","getElementById","P2","P3","P4","recalculate","useTimeOutRef","useCanMove","timeOutRef","npc","npcState","newTime","movementSpeed","useKeyboardEvent","onKeyDown","onKeyUp","keyMap","handleKeyEvent","isKeyDown","type","CODE_SPACE","preventDefault","registerKeys","canPlayerTakeAction","player","isPlayerDead","usePlayerInterval","playerActionSpeedOrNull","useMemo","playerState","usePlayerActionSpeed","MAX_SAFE_INTEGER","handleBombForPlayers","keyEventCode","mapAllPossibleKeyboardKeysForAction","IntervalWrapper","usePlayerEvents","provider","gameType","triggerMove","is3D","config","powerUps","bomb","_players","GameType","Local","handleActions","previousIs3D","canMove","move","playerKeyboardConfig","directions","getMoveDirectionFromKeyMap","useEvents","handleNpcActions","pId","currentPlayer","getSquareCoordinatesFromSquareOrTopLeftCoordinates","movement","bestMovementNode","npcAction"],"mappings":"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","file":"static/js/4.a72bb75d.chunk.js","sourcesContent":["const sleep = (duration = 1000) => {\n\treturn new Promise(r => {\n\t\tsetTimeout(r, duration);\n\t});\n};\n\n/**\n * Wraps the button on click with a blur event to undo auto on focus. This is\n * especially annoying when view is changed and the user hits the \"Space\"\n * button and it switches the view back as it's \"focus\"ed on.\n *\n * @param cb Curried function where callback is wrapped with this utility.\n * @returns Base event cb\n */\nconst wrapPreventFocusLock = (\n\tcb: (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => void\n) => (e: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n\t// undo onFocus lock\n\te.currentTarget.blur();\n\tcb(e);\n};\n\nconst doesNotExist = (value: any) => value === null || value === undefined;\n\nconst findEnumKeyFromValue = (enumerable: object, key: string) => {\n\treturn Object.keys(enumerable)[Object.values(enumerable).indexOf(key)];\n};\n\nexport { sleep, wrapPreventFocusLock, doesNotExist, findEnumKeyFromValue };\n","import { keyframes } from 'styled-components';\n\n/** @see https://codepen.io/nelledejones/pen/gOOPWrK#L68 */\nconst bounceAnimation = (withOpacity = false) => keyframes`\n\t0% { transform: scale(0, 0); }\n\t25% { transform: scale(0.9, 1.1); }\n\t50% { transform: scale(1.1, 0.9); }\n\t75% { transform: scale(0.95, 1.05); }\n\t100% { transform: scale(1, 1); ${(withOpacity && 'opacity: 1;') || ''} }\n`;\n\nconst ghostAnimation = (size: number, color: string) => keyframes`\n\t0%, 100% { \n\t\ttransform: translateY(0px); \n\t\tbox-shadow: 0 10px 10px #000000;\n\t}\n\t50% {\n\t\ttransform: translateY(-10px);\n\t\tbox-shadow: 0 20px ${Math.ceil(size / 6) + 10}px ${color};\n\t}\n`;\n\nexport { bounceAnimation, ghostAnimation };\n","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faBookDead } from '@fortawesome/free-solid-svg-icons';\nimport {\n\tFontAwesomeIconProps,\n\tPlayerId,\n\tTopLeftCoordinates,\n} from 'containers/Game/types';\nimport theme from 'theme';\nimport { GameConfigRanges } from 'store/redux/reducers/game/types';\nimport { useEffect } from 'react';\nimport TileIcon from './TileIcon';\nimport { SpriteCharacterProps } from './SpriteCharacter';\n\nconst DeadIcon = (props: FontAwesomeIconProps) => (\n\t<FontAwesomeIcon icon={faBookDead} {...props} />\n);\n\ninterface Props extends Omit<SpriteCharacterProps, 'onPlayerIsWalking'> {\n\texplodingDuration: GameConfigRanges.ExplodingDuration;\n\tcoordinates: TopLeftCoordinates;\n\tonDeathAnimationComplete?: (playerId: PlayerId) => void;\n}\n\nconst DeadCharacter = ({\n\tid,\n\t// name,\n\tsize,\n\texplodingDuration,\n\tcoordinates: { top, left },\n\tonDeathAnimationComplete,\n}: Props) => {\n\tuseEffect(() => {\n\t\tsetTimeout(() => {\n\t\t\tonDeathAnimationComplete?.(id);\n\t\t}, explodingDuration * 1000 + 1000);\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, []);\n\treturn (\n\t\t<TileIcon\n\t\t\t$top={top}\n\t\t\t$left={left}\n\t\t\t$size={size}\n\t\t\t$animationDelay={`${explodingDuration}s`}\n\t\t>\n\t\t\t<DeadIcon color={theme.palette.color.default} />\n\t\t\t{/* <div className=\"name\">{name}</div> */}\n\t\t</TileIcon>\n\t);\n};\n\nexport default DeadCharacter;\n","import { bounceAnimation } from 'animations';\nimport styled, { css } from 'styled-components';\n\nconst TileIcon = styled.div<{\n\t$size: number;\n\t$top: number;\n\t$left: number;\n\t$animationDelay?: string;\n}>`\n\tposition: absolute;\n\tdisplay: flex;\n\tjustify-content: center;\n\talign-items: center;\n\topacity: 0;\n\tsvg {\n\t\theight: 100% !important;\n\t\twidth: 100% !important;\n\t\tmax-width: 70%;\n\t\tmax-height: 80%;\n\t}\n\t${({ $size, $animationDelay, $top, $left }) => css`\n\t\ttop: ${$top}px;\n\t\tleft: ${$left}px;\n\t\twidth: ${$size}px;\n\t\theight: ${$size}px;\n\t\tanimation: ${bounceAnimation(true)} var(--block-animation-duration)\n\t\t\t${$animationDelay || ''} ease-out forwards;\n\t`}\n`;\n\nexport default TileIcon;\n","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport {\n\tfaShoePrints,\n\tfaHeart,\n\tfaBomb,\n\tfaPrescriptionBottleAlt,\n} from '@fortawesome/free-solid-svg-icons';\nimport { PowerUp } from 'enums';\nimport theme from 'theme';\nimport { FontAwesomeIconProps } from 'containers/Game/types';\n\nconst ShoePrintsIcon = (props: FontAwesomeIconProps) => (\n\t<FontAwesomeIcon icon={faShoePrints} {...props} />\n);\nconst HeartIcon = (props: FontAwesomeIconProps) => (\n\t<FontAwesomeIcon icon={faHeart} {...props} />\n);\nconst BombIcon = (props: FontAwesomeIconProps) => (\n\t<FontAwesomeIcon icon={faBomb} {...props} />\n);\nconst PrescriptionBottleAltIcon = (props: FontAwesomeIconProps) => (\n\t<FontAwesomeIcon icon={faPrescriptionBottleAlt} {...props} />\n);\n\nconst icons: Record<\n\tPowerUp,\n\t{ icon: (props: FontAwesomeIconProps) => JSX.Element; color: string }\n> = {\n\t[PowerUp.Life]: {\n\t\tcolor: theme.palette.color.success,\n\t\ticon: HeartIcon,\n\t},\n\t[PowerUp.BombCount]: {\n\t\tcolor: theme.palette.color.error,\n\t\ticon: BombIcon,\n\t},\n\t[PowerUp.BombSize]: {\n\t\tcolor: theme.palette.color.warning,\n\t\ticon: PrescriptionBottleAltIcon,\n\t},\n\t[PowerUp.MovementSpeed]: {\n\t\tcolor: theme.palette.color.info,\n\t\ticon: ShoePrintsIcon,\n\t},\n};\n\nexport default icons;\n","import { Direction } from 'enums';\nimport { useEffect, useRef, useState } from 'react';\nimport { getMoveDirectionFromKeyboardCode } from 'utils/game';\nimport styled, { css } from 'styled-components';\nimport theme from 'theme';\nimport { CharacterProps } from './Character';\nimport './SpriteCharacter.scss';\nimport spriteShadow from './character-shadow.png';\nimport spriteImage from './character-skin-default.png';\n\nconst SPRITE_SQUARE_SIZE = 32;\nconst Wrapper = styled.div<{ $size: number; $name: string }>`\n\t${({ $size, $name }) => {\n\t\t// CALCULATED\n\t\tconst pixelMultiplier = $size / SPRITE_SQUARE_SIZE;\n\t\tconst spriteSize = pixelMultiplier * SPRITE_SQUARE_SIZE;\n\t\tconst spriteSheetSize = spriteSize * 4;\n\t\tconst spriteSheetSquareSize = pixelMultiplier * -1 * SPRITE_SQUARE_SIZE;\n\t\tconst translateDiff = ($size / 4) * -1;\n\t\tconst topDiff = Math.min(-15, translateDiff * 2.5);\n\t\tconst labelFontSize = Math.min(30, Math.ceil(spriteSize / 6));\n\t\tconst labelTopDiff = Math.floor(spriteSize / (5 * 2));\n\t\t// const labelMaxWidth = Math.ceil(spriteSize * 0.8);\n\t\tconst labelMaxWidth = $name.length * 20 + spriteSize / 20;\n\n\t\tconst spriteSizing = `\n\t\t\twidth: ${spriteSize}px;\n\t\t\theight: ${spriteSize}px;\n\t\t`;\n\t\tconst spriteSheetSizing = `\n\t\t\twidth: ${spriteSheetSize}px;\n\t\t\theight: ${spriteSheetSize}px;\n\t\t`;\n\n\t\treturn css`\n\t\t\tposition: absolute;\n\t\t\tz-index: 9999;\n\t\t\t${spriteSizing};\n\t\t\ttransition-duration: 450ms;\n\n\t\t\t&#P1 .name {\n\t\t\t\tbackground-color: ${theme.palette.color.warning};\n\t\t\t}\n\t\t\t&#P2 .name {\n\t\t\t\tbackground-color: ${theme.palette.color.info};\n\t\t\t}\n\t\t\t&#P3 .name {\n\t\t\t\tbackground-color: ${theme.palette.color.success};\n\t\t\t}\n\t\t\t&#P4 .name {\n\t\t\t\tbackground-color: ${theme.palette.color.error};\n\t\t\t}\n\n\t\t\t.character {\n\t\t\t\ttop: ${topDiff}px;\n\t\t\t\ttransform: translate(${translateDiff}px);\n\n\t\t\t\t${spriteSizing};\n\t\t\t\toverflow: hidden;\n\t\t\t\tposition: relative;\n\t\t\t\t/* MOVEMENT TRANSITION */\n\t\t\t\ttransition-duration: 400ms;\n\n\t\t\t\t& .name {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\tleft: 0;\n\t\t\t\t\tright: 0;\n\t\t\t\t\ttop: ${labelTopDiff}px;\n\t\t\t\t\tfont-size: ${labelFontSize}px;\n\t\t\t\t\tmax-width: ${labelMaxWidth}px;\n\t\t\t\t\tfont-weight: bold;\n\t\t\t\t\tborder: 1px dashed white;\n\t\t\t\t\tborder-radius: 9999px;\n\t\t\t\t\topacity: 1;\n\t\t\t\t\tmargin: auto;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\n\t\t\t\t& .shadow {\n\t\t\t\t\t${spriteSizing};\n\t\t\t\t\topacity: 0.75;\n\t\t\t\t}\n\n\t\t\t\t& .spritesheet {\n\t\t\t\t\t${spriteSheetSizing};\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\ttop: 0;\n\t\t\t\t\tleft: 0;\n\t\t\t\t}\n\n\t\t\t\t/* DIRECTION */\n\t\t\t\t&[data-facing='Right'] .spritesheet {\n\t\t\t\t\ttop: ${spriteSheetSquareSize * 1}px;\n\t\t\t\t}\n\t\t\t\t&[data-facing='Up'] .spritesheet {\n\t\t\t\t\ttop: ${spriteSheetSquareSize * 2}px;\n\t\t\t\t}\n\t\t\t\t&[data-facing='Left'] .spritesheet {\n\t\t\t\t\ttop: ${spriteSheetSquareSize * 3}px;\n\t\t\t\t}\n\n\t\t\t\t&[data-walking='true'] {\n\t\t\t\t\t/* MOVEMENT ANIMATION */\n\t\t\t\t\t.spritesheet {\n\t\t\t\t\t\tanimation: walkAnimation 0.6s steps(4) infinite;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* SHADOW ANIMATION */\n\t\t\t\t\t.shadow {\n\t\t\t\t\t\tanimation: shadowAnimation 0.3s infinite;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* HIGHLIGHT/DAMAGE ANIMATION */\n\t\t\t\t&[data-highlight='true'] .spritesheet {\n\t\t\t\t\tanimation: opacityAnimation 0.6s steps(4) infinite;\n\t\t\t\t}\n\t\t\t}\n\t\t`;\n\t}}\n`;\n\nconst ANIMATION_STOP_THROTTLE_DURATION = 200;\n\ninterface Props extends Omit<CharacterProps, 'tileSize' | 'is3D' | 'size'> {\n\t// size can be any number by default, unless it's a game character\n\tsize: number;\n}\n\ntype UseSpriteCharacterAction = Omit<Props, 'coordinates' | 'name' | 'size'> & {\n\tshouldBindEvent: boolean;\n\t// setters\n\tsetDirection: React.Dispatch<React.SetStateAction<Direction>>;\n\tsetIsWalking: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nconst useSpriteCharacterAction = ({\n\tid,\n\tshouldBindEvent,\n\tkeyboardConfig,\n\t// state setter\n\tonPlayerIsWalking,\n\t// setters\n\tsetDirection,\n\tsetIsWalking,\n}: UseSpriteCharacterAction) => {\n\tconst lastMovementTime = useRef(new Date().getTime());\n\n\tuseEffect(() => {\n\t\t// ignore the npc action\n\t\tconst getDirection = (e: KeyboardEvent) => {\n\t\t\treturn keyboardConfig\n\t\t\t\t? getMoveDirectionFromKeyboardCode(e.code, keyboardConfig)\n\t\t\t\t: null;\n\t\t};\n\n\t\tconst updateDirection = (newDirection: Direction) => {\n\t\t\tsetDirection(newDirection);\n\t\t};\n\n\t\tconst handleKeyDown = (e: KeyboardEvent) => {\n\t\t\tif (!shouldBindEvent) return;\n\n\t\t\tconst newDirection = getDirection(e);\n\t\t\tif (!newDirection) {\n\t\t\t\tonPlayerIsWalking?.(false, id);\n\t\t\t\tsetIsWalking(false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlastMovementTime.current = new Date().getTime();\n\t\t\tsetIsWalking(true);\n\t\t\tupdateDirection(newDirection);\n\t\t};\n\n\t\tconst handleKeyUp = () => {\n\t\t\tif (!shouldBindEvent) return;\n\t\t\t// keypress-move: keydown + keyup, i.e. D, D, D (not hold D)\n\t\t\t// Only stop the moving animation after the player goes idle\n\t\t\t// for some duration. This allows us to use keypress to move\n\t\t\t// and still have a move animation (instead of keydown).\n\t\t\t// This is needed because otherwise keypress-move wont trigger\n\t\t\t// animations.\n\t\t\tsetTimeout(() => {\n\t\t\t\tconst delayedCurrentTime =\n\t\t\t\t\tnew Date().getTime() - ANIMATION_STOP_THROTTLE_DURATION;\n\t\t\t\tif (lastMovementTime.current >= delayedCurrentTime) return;\n\t\t\t\tsetIsWalking(false);\n\t\t\t\tonPlayerIsWalking?.(false, id);\n\t\t\t}, ANIMATION_STOP_THROTTLE_DURATION);\n\t\t};\n\n\t\t//\n\t\tif (shouldBindEvent) {\n\t\t\tdocument.addEventListener('keydown', handleKeyDown);\n\t\t\tdocument.addEventListener('keyup', handleKeyUp);\n\t\t}\n\t\treturn () => {\n\t\t\tdocument.removeEventListener('keydown', handleKeyDown);\n\t\t\tdocument.removeEventListener('keyup', handleKeyUp);\n\t\t};\n\t}, [\n\t\tid,\n\t\tkeyboardConfig,\n\t\tonPlayerIsWalking,\n\t\tsetDirection,\n\t\tsetIsWalking,\n\t\tshouldBindEvent,\n\t]);\n};\n\nconst SpriteCharacter = ({\n\tid,\n\tcurrentOnlinePlayerId,\n\tname,\n\tcoordinates: { top, left },\n\tstyle,\n\tkeyboardConfig,\n\thighlight,\n\tsize,\n\tonPlayerIsWalking,\n\tisWalking: defaultIsWalking = false,\n\tdirection: defaultDirection = Direction.DOWN,\n\tisNPC = false,\n\t...rest\n}: Props) => {\n\t/** Direction being faced */\n\tconst [eventDirection, setEventDirection] = useState<Direction>(\n\t\tdefaultDirection\n\t);\n\tconst [eventIsWalking, setEventIsWalking] = useState<boolean>(\n\t\tdefaultIsWalking\n\t);\n\n\t// We only want to bind the event if it's:\n\t// - not online game\n\t// - online game and it's the current player\n\tconst shouldBindEvent =\n\t\t!isNPC && (!currentOnlinePlayerId || id === currentOnlinePlayerId);\n\n\tuseSpriteCharacterAction({\n\t\tid,\n\t\tcurrentOnlinePlayerId,\n\t\tkeyboardConfig,\n\t\tshouldBindEvent,\n\t\t// state setter\n\t\tonPlayerIsWalking,\n\t\t// setters\n\t\tsetDirection: setEventDirection,\n\t\tsetIsWalking: setEventIsWalking,\n\t});\n\n\tlet isWalking = defaultIsWalking;\n\tlet direction = defaultDirection;\n\n\tif (shouldBindEvent) {\n\t\tisWalking = eventIsWalking;\n\t\tdirection = eventDirection;\n\t}\n\n\treturn (\n\t\t<Wrapper\n\t\t\tid={id}\n\t\t\tstyle={{\n\t\t\t\t...style,\n\t\t\t\ttop,\n\t\t\t\tleft,\n\t\t\t}}\n\t\t\tclassName=\"character-wrapper\"\n\t\t\t{...rest}\n\t\t\t$size={size * 2}\n\t\t\t$name={name}\n\t\t>\n\t\t\t<div\n\t\t\t\tclassName=\"character\"\n\t\t\t\tdata-facing={direction}\n\t\t\t\tdata-walking={isWalking.toString()}\n\t\t\t\tdata-highlight={highlight}\n\t\t\t>\n\t\t\t\t<div className=\"name\">{name}</div>\n\t\t\t\t<img\n\t\t\t\t\tclassName=\"shadow pixel-art\"\n\t\t\t\t\tsrc={spriteShadow}\n\t\t\t\t\talt=\"sprite skin\"\n\t\t\t\t/>\n\t\t\t\t<img\n\t\t\t\t\tclassName=\"spritesheet pixel-art\"\n\t\t\t\t\tsrc={spriteImage}\n\t\t\t\t\talt=\"sprite skin\"\n\t\t\t\t/>\n\t\t\t</div>\n\t\t</Wrapper>\n\t);\n};\n\nexport type { Props as SpriteCharacterProps };\nexport default SpriteCharacter;\n","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAWUlEQVRYR+3XsQkAIAxEUe2cRXADx3cDwVksJYX970T41sE7Xqrk9Pjlx/nJAgoooIACCiiggAIKKKDAXwKt9k0uqblGIXMxgwVo+A2mJSyABYKWroHyx58Hv0cUIWfm8TkAAAAASUVORK5CYII=\"","export default \"data:image/png;base64,UklGRuYBAABXRUJQVlA4TNkBAAAvf8AfEDegkI0kaB1Wc63vv4M4DQUByDA6SKk4ex2mqG0bqCCKrfwp7N5em/8A4P9XnTtjLpKQBLi1tbdt/gbqnTCAN/D5RCygH6yhQ4C1GfefQQG/fjA4FhH9Z9i2bZjkAbZdhsAn0N9Qh3Rps6Tr7enSZ9lZ1PV+6bPsLO4q4Fj1ORugiqJzAdemHQCwqMszM8vOoq4wzXNrso4rVOW6YeXnwAFDfg66i/MBl3QOm5+DDrAmX0BjNK5QAfYsOYVzJHCjcr1VjGTyTmZhrj2PUeUKvuZIeWc7iQ6TdK4URIcJSXIQyS75V0Q70f+F9g48tFcs4Nq6A4Vd69w7RGdRF4UBhmRnWZd1wlhZB3tQuabj0JFQXb4+n2pMKlfoeHgRzhW9cK7ZcyKVa2Kehcn3SWRURueqkpdcSWIEE0jv+ne4d0DeKxZw7a5jV/aO4IDByDlGSZe/VvYc1dUpu+RzNrlqa+ZxyrtOPESNyzs+5s9FtbRGUT2mUeUKdapHZe4wkzZ3oH+muYNvAMjO8q5tO7CMS7MHeJRxrSt3gHsgVzBlXYOUG3QYOtK4yLpTq8oVqMX4dFDlEh+OrVHlConjTLpcgrklARpJcDYpKl0xNco1wgRTwLUPTQA=\"","import { useCallback, useEffect, useRef } from 'react';\n\ntype Callback = () => void;\n\n/**\n * setInterval hook.\n *\n * @see https://overreacted.io/making-setinterval-declarative-with-react-hooks/#just-show-me-the-code\n *\n * @param callback Method to call in each interval.\n * @param delay Delay for interval (in milliseconds).\n * @param shouldStop Some condition to trigger a stop on the interval.\n *\n * @returns stopper for the interval\n */\nconst useInterval = (\n\tcallback: Callback,\n\tdelay: number,\n\tshouldStop: boolean\n) => {\n\tconst savedCallback = useRef<Callback>();\n\tconst id = useRef<NodeJS.Timeout>();\n\n\t// Remember the latest callback.\n\tuseEffect(() => {\n\t\tsavedCallback.current = callback;\n\t}, [callback]);\n\n\tconst clearLastInterval = useCallback(() => {\n\t\tif (!id.current) return;\n\t\tclearInterval(id.current as NodeJS.Timeout);\n\t}, []);\n\n\tconst triggerCb = useCallback(() => {\n\t\tsavedCallback.current?.();\n\t}, []);\n\n\t// Set up the interval.\n\tuseEffect(() => {\n\t\tif (!shouldStop) id.current = setInterval(triggerCb, delay);\n\t\treturn () => clearLastInterval();\n\t}, [delay, shouldStop, clearLastInterval, triggerCb]);\n\n\t// Stop the interval if the stop is requested\n\tuseEffect(() => {\n\t\tif (shouldStop) clearLastInterval();\n\t}, [shouldStop, clearLastInterval]);\n\n\treturn clearLastInterval;\n};\n\nexport default useInterval;\n","import { useEffect, useRef } from 'react';\n\nconst usePrevious = (value: any) => {\n\tconst ref = useRef();\n\n\tuseEffect(() => {\n\t\tref.current = value;\n\t}, [value]);\n\n\treturn ref.current;\n};\n\nexport default usePrevious;\n","import {\n\tGameMap,\n\tNPCActionFn,\n\tPlayers,\n\tSquare,\n\tSquareCoordinates,\n} from 'containers/Game/types';\nimport { Direction, Player, PowerUp, Tile } from 'enums';\nimport { Bombs, GameConfig } from 'store/redux/reducers/game/types';\nimport {\n\tgetExplosionResults,\n\tgetPoweredUpValue,\n\tgetSquareCoordinatesFromSquareOrTopLeftCoordinates,\n\tisSquareOutOfBoundaries,\n} from './game';\nimport { getRandomInt } from './math';\n\n// allow debugging in prod\n// @ts-ignore\nwindow.NPC_DEBUG = false;\nconst log = (value: any, label = '') => {\n\t// @ts-ignore\n\tif (!window.NPC_DEBUG) return;\n\tconsole.log(...[label, value].filter(Boolean));\n};\n\ntype NpcStore = {\n\tid: number;\n\tparentNodes: MovementNode[];\n\tlastBombTime: number;\n\tdropBomb: () => void;\n\tgameMap: GameMap;\n\tplayers: Players;\n\tbombs: Bombs;\n\tpowerUpConfig: GameConfig['powerUps'];\n\tsizes: GameConfig['sizes'];\n\tbombDuration: GameConfig['duration']['bomb'];\n} | null;\nlet Store: NpcStore;\n\ntype Score = number | undefined;\n\nenum NPCScore {\n\tIsDanger = -10000,\n\tIsNonBreakingTile = -100,\n\tIsNonAdjacentNonBreakingTile = -5,\n\tIsStuck = 0,\n\tIsEmptyTile = 2,\n\tIsBreakingTile = 3,\n\tIsPlayer = 4,\n\t/** If the current and the next spots are fire, we need to get out */\n\tIsPossibleFireExit = 1,\n\tIsPowerUp = 1000,\n}\n\ntype MovementNode = {\n\tscore: Score;\n\tparentId: number | null;\n\thasChildren: boolean;\n\tdirection: Direction;\n\tlevel: number;\n};\n\ntype MovementNodeWithKey = {\n\t[key: number]: MovementNode;\n};\n\nconst isDifferentSquare = (\n\tnewCoordinates: SquareCoordinates,\n\toldCoordinates: SquareCoordinates\n) => {\n\tconst { ySquare: newYSquare, xSquare: newXSquare } = newCoordinates;\n\tconst { ySquare: oldYSquare, xSquare: oldXSquare } = oldCoordinates;\n\n\treturn newYSquare !== oldYSquare || newXSquare !== oldXSquare;\n};\n\nconst isSquareAPlayer = (square: Square) => {\n\treturn Object.values<Square>(Player).includes(square);\n};\n\nconst isSquareAPossibleFire = (currentSquareCoordinates: SquareCoordinates) => {\n\tconst bombs = Object.values(Store!.bombs);\n\tif (!bombs.length) return false;\n\n\tconst _fireCoordinates: Array<SquareCoordinates> = [];\n\n\tbombs.forEach(({ playerId, top, left }) => {\n\t\tconst { players } = Store!;\n\t\tconst { coordinatesToSetOnFire } = getExplosionResults(\n\t\t\tStore!.gameMap,\n\t\t\t{ top, left },\n\t\t\tplayers[playerId]?.state\n\t\t\t\t? getPoweredUpValue(\n\t\t\t\t\t\tplayers[playerId]!.state,\n\t\t\t\t\t\tPowerUp.BombSize,\n\t\t\t\t\t\tStore!.powerUpConfig\n\t\t\t\t  )\n\t\t\t\t: Store!.powerUpConfig.defaults[PowerUp.BombSize],\n\t\t\tStore!.sizes\n\t\t);\n\t\tObject.values(coordinatesToSetOnFire)\n\t\t\t.flat()\n\t\t\t.forEach(squareCoordinates => {\n\t\t\t\t_fireCoordinates.push(squareCoordinates);\n\t\t\t});\n\t});\n\n\treturn (\n\t\t_fireCoordinates.findIndex(fireSquareCoordinates => {\n\t\t\treturn !isDifferentSquare(\n\t\t\t\tfireSquareCoordinates,\n\t\t\t\tcurrentSquareCoordinates\n\t\t\t);\n\t\t}) >= 0\n\t);\n};\n\nconst isAdjacent = (\n\t{ ySquare: newYSquare, xSquare: newXSquare }: SquareCoordinates,\n\t{ ySquare: oldYSquare, xSquare: oldXSquare }: SquareCoordinates\n) => {\n\treturn (\n\t\t// Directly top or below. If left coordinate is the same and it is +-1 top coordinate\n\t\t// Place a bomb\n\t\t(newXSquare === oldXSquare &&\n\t\t\t(newYSquare === oldYSquare + 1 || newYSquare === oldYSquare - 1)) ||\n\t\t// directly left or right. Same idea as above but for +1 left coordinate\n\t\t(newYSquare === oldYSquare &&\n\t\t\t(newXSquare === oldXSquare + 1 || newXSquare === oldXSquare - 1))\n\t);\n};\n\nconst dropBombAndRunOrScoreTarget = (\n\tnewCoordinates: SquareCoordinates,\n\toldCoordinates: SquareCoordinates,\n\ttargetScore: Score,\n\trunScore?: -100\n) => {\n\t// TODO: is this necessary? it's already the nextSquare\n\tif (isAdjacent(newCoordinates, oldCoordinates)) {\n\t\t// TODO: move this up to usePlayerEvents\n\t\tconst currentTime = new Date().getTime();\n\t\tif (\n\t\t\tStore!.lastBombTime <=\n\t\t\tcurrentTime -\n\t\t\t\tObject.values(Store!.bombDuration).reduce(\n\t\t\t\t\t(acc, duration) => acc + duration,\n\t\t\t\t\t0\n\t\t\t\t) *\n\t\t\t\t\t1000\n\t\t) {\n\t\t\tStore!.dropBomb();\n\t\t\tStore!.lastBombTime = currentTime;\n\t\t}\n\t\treturn runScore;\n\t}\n\tif (isDifferentSquare(newCoordinates, oldCoordinates)) {\n\t\treturn targetScore;\n\t}\n\n\treturn null;\n};\n\nconst generateScore = (\n\tnewCoordinates: SquareCoordinates,\n\toldCoordinates: SquareCoordinates,\n\tlevel: number\n): number | undefined => {\n\tconst { ySquare: newYSquare, xSquare: newXSquare } = newCoordinates;\n\n\tif (isSquareOutOfBoundaries(newCoordinates, Store!.sizes.map)) {\n\t\treturn undefined;\n\t}\n\n\tconst newSquare = Store!.gameMap[newYSquare][newXSquare];\n\t// TODO: Please comment\n\tif (isSquareAPossibleFire(newCoordinates)) {\n\t\tif (isSquareAPossibleFire(oldCoordinates)) {\n\t\t\treturn NPCScore.IsPossibleFireExit;\n\t\t}\n\t\treturn NPCScore.IsDanger;\n\t}\n\tif (Object.values(PowerUp).includes(newSquare as PowerUp)) {\n\t\treturn NPCScore.IsPowerUp * level;\n\t}\n\tif (!isDifferentSquare(newCoordinates, oldCoordinates)) {\n\t\treturn NPCScore.IsStuck;\n\t}\n\tif (newSquare === Tile.Empty) {\n\t\treturn NPCScore.IsEmptyTile;\n\t}\n\tif (isSquareAPlayer(newSquare)) {\n\t\tconst score = dropBombAndRunOrScoreTarget(\n\t\t\tnewCoordinates,\n\t\t\toldCoordinates,\n\t\t\tNPCScore.IsPlayer\n\t\t);\n\t\tif (score !== null) return score;\n\t}\n\tif (newSquare === Tile.Breaking) {\n\t\tif (isSquareAPossibleFire(oldCoordinates)) {\n\t\t\treturn NPCScore.IsDanger;\n\t\t}\n\t\tconst score = dropBombAndRunOrScoreTarget(\n\t\t\tnewCoordinates,\n\t\t\toldCoordinates,\n\t\t\tNPCScore.IsBreakingTile\n\t\t);\n\t\tif (score !== null) return score;\n\t}\n\tif (newSquare === Tile.NonBreaking) {\n\t\t// TODO: is this necessary? it's already the nextSquare\n\t\tif (isAdjacent(newCoordinates, oldCoordinates)) {\n\t\t\treturn NPCScore.IsNonBreakingTile;\n\t\t}\n\t\treturn NPCScore.IsNonAdjacentNonBreakingTile;\n\t}\n\n\treturn NPCScore.IsStuck;\n};\n\nconst generateMovementTree = (\n\tnewCoordinates: SquareCoordinates,\n\toldCoordinates: SquareCoordinates,\n\tlevel: number = 1,\n\tparentId: number | null = null\n) => {\n\tconst { ySquare: newYSquare, xSquare: newXSquare } = newCoordinates;\n\tlet playerMovementTree: MovementNodeWithKey = {};\n\n\tObject.values(Direction).forEach(direction => {\n\t\tlet _newYSquare = newYSquare;\n\t\tlet _newXSquare = newXSquare;\n\n\t\tStore!.id++;\n\n\t\tswitch (direction) {\n\t\t\tcase Direction.LEFT:\n\t\t\t\t_newXSquare--;\n\t\t\t\tbreak;\n\t\t\tcase Direction.UP:\n\t\t\t\t_newYSquare--;\n\t\t\t\tbreak;\n\t\t\tcase Direction.RIGHT:\n\t\t\t\t_newXSquare++;\n\t\t\t\tbreak;\n\t\t\tcase Direction.DOWN:\n\t\t\t\t_newYSquare++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tconst score = generateScore(\n\t\t\t{ ySquare: _newYSquare, xSquare: _newXSquare },\n\t\t\toldCoordinates,\n\t\t\tlevel\n\t\t);\n\n\t\tplayerMovementTree[Store!.id] = {\n\t\t\tscore,\n\t\t\thasChildren: level > 0 && score !== undefined,\n\t\t\tparentId,\n\t\t\tdirection,\n\t\t\tlevel,\n\t\t};\n\t\tif (level > 0 && !!score) {\n\t\t\tplayerMovementTree = {\n\t\t\t\t...playerMovementTree,\n\t\t\t\t...generateMovementTree(\n\t\t\t\t\t{ ySquare: _newYSquare, xSquare: _newXSquare },\n\t\t\t\t\toldCoordinates,\n\t\t\t\t\tlevel - 1,\n\t\t\t\t\tStore!.id\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t});\n\n\treturn playerMovementTree!;\n};\n\nconst findNodeWithHighestScore = (movementNodes: MovementNode[]) => {\n\treturn movementNodes.reduce((acc, current) => {\n\t\tlet retVal = current;\n\t\tif (current.score === undefined) {\n\t\t\tretVal = acc;\n\t\t}\n\t\tif (acc.score! > current.score!) {\n\t\t\tretVal = acc;\n\t\t}\n\t\tif (acc.score! < current.score!) {\n\t\t\tretVal = current;\n\t\t}\n\t\tif (acc.score === current.score) {\n\t\t\tconst randomInt = getRandomInt(2);\n\t\t\tretVal = randomInt === 0 ? current : acc;\n\t\t}\n\n\t\treturn retVal;\n\t});\n};\n\nconst groupMovementNodesByParentId = (movementNodes: MovementNode[]) => {\n\tconst movementNodesGroupedById: { [key: number]: MovementNode[] } = {};\n\n\tmovementNodes.forEach(movementNode => {\n\t\tconst movementNodeParentId = movementNode.parentId!;\n\t\tif (movementNodesGroupedById[movementNodeParentId]) {\n\t\t\tmovementNodesGroupedById[movementNodeParentId].push(movementNode);\n\t\t} else {\n\t\t\tmovementNodesGroupedById[movementNodeParentId] = [movementNode];\n\t\t}\n\t});\n\treturn movementNodesGroupedById;\n};\n\nconst getTotalScoreOfAllNodes = (\n\tmovementTree: MovementNodeWithKey,\n\tparentId: number | undefined | null = undefined\n) => {\n\tlet validMovementNodes: MovementNode[];\n\n\tif (parentId !== null) {\n\t\tif (parentId === undefined) {\n\t\t\tvalidMovementNodes = Object.values(movementTree).filter(\n\t\t\t\tmovementNode => !movementNode.hasChildren\n\t\t\t);\n\t\t} else {\n\t\t\tvalidMovementNodes = Object.values(movementTree).filter(\n\t\t\t\tmovementNode =>\n\t\t\t\t\tmovementNode.parentId === movementTree[parentId!].parentId\n\t\t\t);\n\t\t}\n\n\t\tconst movementNodesGroupedByParentId = groupMovementNodesByParentId(\n\t\t\tvalidMovementNodes!\n\t\t);\n\n\t\tObject.entries(movementNodesGroupedByParentId).forEach(\n\t\t\t([groupParentId, movementNodes]) => {\n\t\t\t\tconst _groupParentId =\n\t\t\t\t\tgroupParentId === 'null' ? null : Number(groupParentId);\n\n\t\t\t\tconst nodeWithHighestScore = findNodeWithHighestScore(\n\t\t\t\t\tmovementNodes!\n\t\t\t\t);\n\n\t\t\t\tif (!_groupParentId) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Store!.parentNodes.some(\n\t\t\t\t\t\t\tparentNode =>\n\t\t\t\t\t\t\t\tparentNode.direction ===\n\t\t\t\t\t\t\t\tnodeWithHighestScore.direction\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tStore!.parentNodes.push(nodeWithHighestScore);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// eslint-disable-next-line no-param-reassign\n\t\t\t\t\tmovementTree[_groupParentId].score =\n\t\t\t\t\t\tmovementTree[_groupParentId].score! +\n\t\t\t\t\t\t(nodeWithHighestScore.score!\n\t\t\t\t\t\t\t? nodeWithHighestScore.score\n\t\t\t\t\t\t\t: 0);\n\t\t\t\t\tgetTotalScoreOfAllNodes(movementTree, _groupParentId);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n};\n\nconst findBestMove = (\n\tcurrentCoordinates: SquareCoordinates\n): MovementNode | null => {\n\tStore!.id = 0;\n\tStore!.parentNodes = [];\n\n\tconst movementTree = generateMovementTree(\n\t\tcurrentCoordinates,\n\t\tcurrentCoordinates,\n\t\tundefined\n\t);\n\tlog(currentCoordinates, 'currentCoordinates');\n\tlog(movementTree, 'originalMoves');\n\tgetTotalScoreOfAllNodes(movementTree);\n\tlog(movementTree, 'scoredMoves');\n\n\treturn findNodeWithHighestScore(Store!.parentNodes);\n};\n\nconst npcAction: NPCActionFn = ({\n\tplayerId,\n\tplayers,\n\tgameMap,\n\tbombs,\n\ttriggerMove,\n\tdropBomb,\n\tref,\n\tpowerUpConfig,\n\tsizes,\n\tbombDuration,\n}) => {\n\tconst currentPlayer = players[playerId];\n\tStore = {\n\t\tid: 0,\n\t\tparentNodes: [],\n\t\tlastBombTime: 0,\n\t\tdropBomb: () => dropBomb(playerId),\n\t\tgameMap,\n\t\tbombs,\n\t\tplayers,\n\t\tpowerUpConfig,\n\t\tsizes,\n\t\tbombDuration,\n\t};\n\n\tif (!currentPlayer) return;\n\n\t// eslint-disable-next-line max-len\n\tconst currentSquareCoordinates = getSquareCoordinatesFromSquareOrTopLeftCoordinates(\n\t\tcurrentPlayer.coordinates,\n\t\tsizes.movement\n\t);\n\n\tconst bestMovementNode = findBestMove(currentSquareCoordinates);\n\tlog(bestMovementNode, 'bestMovementNode');\n\n\tif ((bestMovementNode?.score || 0) > 0) {\n\t\ttriggerMove({ playerId, direction: bestMovementNode!.direction, ref });\n\t}\n};\n\nexport { npcAction };\n","import {\n\tGameApi,\n\tKeyboardConfig,\n\tKeyboardEventCode,\n\tKeyMap,\n\tNonNullablePlayerRef,\n\tOnDropBomb,\n\tPlayerId,\n\tPlayers,\n} from 'containers/Game/types';\nimport { GameType, PowerUp } from 'enums';\nimport { useEffect, useMemo, useRef } from 'react';\nimport {\n\tgetMoveDirectionFromKeyMap,\n\tgetPoweredUpValue,\n\tisPlayerDead,\n\tmapAllPossibleKeyboardKeysForAction,\n} from 'utils/game';\nimport { npcAction } from 'utils/npc';\nimport useInterval from 'hooks/useInterval';\nimport usePrevious from 'hooks/usePrevious';\nimport { CODE_SPACE } from 'keycode-js';\nimport { GameConfig, OnTriggerMove, TriggerMove } from '../reducers/game/types';\n\ntype HandleActionsFn = (playerId: PlayerId) => void;\ntype KeyDownAction = (playerId: PlayerId, keys: KeyboardConfig) => void;\n\ntype KeyAction = (keyEventCode: KeyboardEventCode) => void;\n\nconst usePlayerRefs = () => {\n\tconst playerRefs = useRef<{ [key in PlayerId]?: HTMLElement | null }>({\n\t\tP1: document.getElementById('P1'),\n\t\tP2: document.getElementById('P2'),\n\t\tP3: document.getElementById('P3'),\n\t\tP4: document.getElementById('P4'),\n\t});\n\n\tconst recalculate = () => {\n\t\tObject.keys(playerRefs.current).forEach(playerId => {\n\t\t\tplayerRefs.current[playerId as PlayerId] = document.getElementById(\n\t\t\t\tplayerId\n\t\t\t);\n\t\t});\n\t};\n\n\treturn { playerRefs, recalculate };\n};\n\nconst useTimeOutRef = () => {\n\tconst timeOutRef = useRef<Record<PlayerId, number>>({\n\t\tP1: new Date().getTime(),\n\t\tP2: new Date().getTime(),\n\t\tP3: new Date().getTime(),\n\t\tP4: new Date().getTime(),\n\t});\n\n\treturn timeOutRef;\n};\n\nconst useCanMove = (\n\tplayers: Players,\n\tpowerUpConfig: GameConfig['powerUps']\n) => {\n\tconst timeOutRef = useTimeOutRef();\n\tconst canMove = (playerId: PlayerId) => {\n\t\tconst npc = players[playerId];\n\t\tif (!npc) return false;\n\t\tconst { state: npcState } = npc;\n\t\tconst newTime = new Date().getTime();\n\t\tconst movementSpeed = getPoweredUpValue(\n\t\t\tnpcState,\n\t\t\tPowerUp.MovementSpeed,\n\t\t\tpowerUpConfig\n\t\t);\n\t\tif (newTime - timeOutRef.current[playerId]! > movementSpeed) {\n\t\t\ttimeOutRef.current[playerId] = newTime;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\treturn canMove;\n};\n\nconst useEvents = ({\n\ttriggerMove,\n\tplayers,\n\ttimeOutRef,\n\tkeyMap,\n\tis3D,\n\tpowerUpConfig,\n}: {\n\ttriggerMove: OnTriggerMove;\n\tplayers: Players;\n\tkeyMap: React.MutableRefObject<KeyMap>;\n\ttimeOutRef: React.MutableRefObject<Record<PlayerId, number>>;\n\tis3D: boolean;\n\tpowerUpConfig: GameConfig['powerUps'];\n}) => {\n\tconst { playerRefs, recalculate } = usePlayerRefs();\n\tconst previousIs3D = usePrevious(is3D);\n\n\tuseEffect(() => {\n\t\tif (previousIs3D === is3D) return;\n\t\trecalculate();\n\t}, [is3D, previousIs3D, recalculate]);\n\n\tconst canMove = useCanMove(players, powerUpConfig);\n\n\tconst move: KeyDownAction = (playerId, playerKeyboardConfig) => {\n\t\tconst directions = getMoveDirectionFromKeyMap(\n\t\t\tkeyMap,\n\t\t\tplayerKeyboardConfig\n\t\t);\n\t\tif (!directions.length) return;\n\n\t\tdirections.forEach(direction => {\n\t\t\ttriggerMove({\n\t\t\t\tplayerId,\n\t\t\t\tdirection,\n\t\t\t\tref: playerRefs.current[playerId] as NonNullablePlayerRef,\n\t\t\t});\n\t\t});\n\t};\n\n\tconst handleActions = (playerId: PlayerId) => {\n\t\tif (!keyMap.current) return;\n\t\tif (!timeOutRef.current) return;\n\t\t// don't do anything if no key is being pressed\n\t\tif (!Object.values(keyMap.current).filter(Boolean).length) return;\n\n\t\tconst { keyboardConfig } = players[playerId]!;\n\t\tif (!keyboardConfig || !Object.keys(keyboardConfig).length) return;\n\n\t\tconst ref = playerRefs.current[playerId];\n\t\tif (!ref) {\n\t\t\tplayerRefs.current[playerId] = document.getElementById(playerId);\n\t\t}\n\n\t\tif (ref && canMove(playerId)) move(playerId, keyboardConfig);\n\t};\n\n\treturn { move, handleActions };\n};\n\nconst useKeyboardEvent = ({\n\tonKeyDown,\n\tonKeyUp,\n}: {\n\tonKeyDown?: KeyAction;\n\tonKeyUp?: KeyAction;\n} = {}) => {\n\tconst keyMap = useRef<KeyMap>({});\n\n\tuseEffect(() => {\n\t\tconst registerKeys = (e: KeyboardEvent, isKeyDown: boolean) => {\n\t\t\t/** @see https://stackoverflow.com/questions/5203407/how-to-detect-if-multiple-keys-are-pressed-at-once-using-javascript#answer-12444641 */\n\t\t\tkeyMap.current[e.code as KeyboardEventCode] = isKeyDown;\n\t\t};\n\n\t\tconst handleKeyEvent = (e: KeyboardEvent) => {\n\t\t\tif (!keyMap.current) return;\n\n\t\t\tconst isKeyDown = e.type === 'keydown';\n\t\t\tif (e.code === CODE_SPACE) e.preventDefault();\n\t\t\tregisterKeys(e, isKeyDown);\n\t\t\tif (isKeyDown) onKeyDown?.(e.code as KeyboardEventCode);\n\t\t\telse onKeyUp?.(e.code as KeyboardEventCode);\n\t\t};\n\n\t\twindow.addEventListener('keyup', handleKeyEvent);\n\t\twindow.addEventListener('keydown', handleKeyEvent);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener('keyup', handleKeyEvent);\n\t\t\twindow.removeEventListener('keydown', handleKeyEvent);\n\t\t};\n\t}, [onKeyDown, onKeyUp]);\n\n\treturn keyMap;\n};\n\nconst usePlayerActionSpeed = (\n\tplayers: Players,\n\tplayerId: PlayerId,\n\tpowerUpConfig: GameConfig['powerUps']\n) => {\n\tconst movementSpeed = useMemo(() => {\n\t\tconst playerState = players[playerId]?.state;\n\t\t// if there is no NPC, lets not call this often\n\t\tif (!playerState) return null;\n\t\treturn getPoweredUpValue(\n\t\t\tplayerState,\n\t\t\tPowerUp.MovementSpeed,\n\t\t\tpowerUpConfig\n\t\t);\n\t}, [playerId, players, powerUpConfig]);\n\n\treturn movementSpeed;\n};\n\nconst canPlayerTakeAction = (\n\tplayers: Players,\n\tplayerId: PlayerId,\n\tpowerUpConfig: GameConfig['powerUps']\n) => {\n\tconst player = players[playerId];\n\t// player doesn't exist\n\tif (!player) return false;\n\t// player is dead\n\tif (isPlayerDead(player.state, powerUpConfig)) return false;\n\n\treturn true;\n};\n\nconst usePlayerInterval = (\n\tplayers: Players,\n\tplayerId: PlayerId,\n\tpowerUpConfig: GameConfig['powerUps'],\n\tcb: HandleActionsFn\n) => {\n\tconst playerActionSpeedOrNull = usePlayerActionSpeed(\n\t\tplayers,\n\t\tplayerId,\n\t\tpowerUpConfig\n\t);\n\n\tuseInterval(\n\t\t() => {\n\t\t\tif (!canPlayerTakeAction(players, playerId, powerUpConfig)) return;\n\t\t\tcb(playerId);\n\t\t},\n\t\tplayerActionSpeedOrNull || Number.MAX_SAFE_INTEGER,\n\t\t!playerActionSpeedOrNull\n\t);\n};\n\nconst handleBombForPlayers = (\n\tplayers: Players,\n\tdropBomb: OnDropBomb,\n\tpowerUpConfig: GameConfig['powerUps']\n) => (keyEventCode: KeyboardEventCode) => {\n\t(Object.keys(players) as Array<PlayerId>).forEach(playerId => {\n\t\tif (canPlayerTakeAction(players, playerId, powerUpConfig)) {\n\t\t\tconst { keyboardConfig } = players[playerId]!;\n\t\t\tif (keyboardConfig) {\n\t\t\t\t// let isKeyPressed = false;\n\t\t\t\tconst bombKeys = mapAllPossibleKeyboardKeysForAction(\n\t\t\t\t\tkeyboardConfig,\n\t\t\t\t\t'DropBomb'\n\t\t\t\t);\n\t\t\t\tif (bombKeys.includes(keyEventCode)) {\n\t\t\t\t\tdropBomb(playerId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n};\n\nconst IntervalWrapper = ({\n\tplayerId,\n\tplayers,\n\tpowerUpConfig,\n\tcb,\n}: {\n\tplayerId: PlayerId;\n\tplayers: Players;\n\tpowerUpConfig: GameConfig['powerUps'];\n\tcb: HandleActionsFn;\n}) => {\n\tusePlayerInterval(players, playerId, powerUpConfig, cb);\n\treturn null;\n};\n\nconst usePlayerEvents = ({\n\tstate,\n\tprovider,\n\ttype: gameType,\n\tplayerId,\n}: GameApi) => {\n\tconst { dropBomb, triggerMove } = provider;\n\tconst {\n\t\tgameMap,\n\t\tbombs,\n\t\tplayers,\n\t\tis3D,\n\t\tconfig: {\n\t\t\tpowerUps: powerUpConfig,\n\t\t\tsizes,\n\t\t\tduration: { bomb: bombDuration },\n\t\t},\n\t} = state;\n\n\tconst { playerRefs } = usePlayerRefs();\n\n\tconst _players = useMemo<Players>(() => {\n\t\treturn gameType === GameType.Local\n\t\t\t? players\n\t\t\t: { [playerId!]: players[playerId!] };\n\t\t// none of the deps will affect this\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [players]);\n\t// }, [gameType, playerId, players]);\n\n\tconst keyMap = useKeyboardEvent({\n\t\tonKeyDown: handleBombForPlayers(_players, dropBomb, powerUpConfig),\n\t});\n\tconst timeOutRef = useTimeOutRef();\n\tconst { handleActions } = useEvents({\n\t\ttriggerMove,\n\t\tplayers: _players,\n\t\ttimeOutRef,\n\t\tkeyMap,\n\t\tis3D,\n\t\tpowerUpConfig,\n\t});\n\n\tconst canMove = useCanMove(players, powerUpConfig);\n\n\tconst handleNpcActions = (pId: PlayerId) => {\n\t\tconst ref = playerRefs.current[pId];\n\n\t\tif (!ref) {\n\t\t\tplayerRefs.current[pId] = document.getElementById(pId);\n\t\t}\n\n\t\tnpcAction({\n\t\t\tplayerId: pId,\n\t\t\tdropBomb,\n\t\t\tgameMap,\n\t\t\tbombs,\n\t\t\tplayers: _players,\n\t\t\ttriggerMove: (props: TriggerMove) => {\n\t\t\t\tif (canMove(pId)) triggerMove(props);\n\t\t\t},\n\t\t\tref: playerRefs.current[pId] as NonNullablePlayerRef,\n\t\t\tpowerUpConfig,\n\t\t\tsizes,\n\t\t\tbombDuration,\n\t\t});\n\t};\n\n\t// URGENT: Since this triggers a move event, if the\n\t// player is on the same explosion fire, he dies\n\t// multiple times\n\t// TODO: In the next update, start these intervals\n\t// when the keys are pressed and not continuously\n\treturn Object.keys(_players).map(pId => {\n\t\t// TODO: online game can also have NPCs, have a check for that\n\t\tconst { isNPC } = _players[pId as PlayerId]!;\n\t\treturn (\n\t\t\t<IntervalWrapper\n\t\t\t\tkey={pId}\n\t\t\t\tplayerId={pId as PlayerId}\n\t\t\t\tplayers={_players}\n\t\t\t\tpowerUpConfig={powerUpConfig}\n\t\t\t\tcb={isNPC ? handleNpcActions : handleActions}\n\t\t\t/>\n\t\t);\n\t});\n};\n\nexport { useKeyboardEvent };\nexport default usePlayerEvents;\n"],"sourceRoot":""}